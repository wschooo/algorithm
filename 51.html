<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //section7. 정렬,그리디,결정알고리즘
        //51. 버블 정렬
        //인접한 두 요소를 검사하여 정렬(오름, 내림)하는 방법
        //예를 들어 오름차순으로 정렬시킨다면 인접한 두 요소를 검사하여 값이 작은 것을 왼쪽에 위치시키고, 값이 큰 것을 오른쪽에 위치시킨다면
        //한번의 회전이 돌았을 때 배열에서 현재 가장 큰 요소가 가장 뒷자리로 밀려나게 됨
        // ex) [1 ,3 ,5, 4, 2]
        // 1번의 회전: 1 3 4 2 5 
        // 2번의 회전: 1 3 2 4 (5)
        // 3번의 회전: 1 2 3 4 (5)
        // 오름차순 정렬 완료

        // 한 번의 회전이 끝나면 결국 가장 큰 요소가 배열의 가장 뒤로 밀려나게 되므로 
        // 가장 뒤에 위치한 요소(배열에서 가장 큰 요소값)는 다음번 탐색에서 제외하고((5)), 다시 앞에서 부터 똑같은 작업을 반복하여
        // 가장 큰 요소만 계속하여 뒤로 보내주는 작업을 하는 것임
        // 결국 회전 당 가장 큰 값들이 뒤에서 부터 차근차근 쌓이게 되므로 오름차순이 완성 됨
        // 내림차순의 경우 이와 반대로 가장 작은 값들을 뒤로 밀면 되는 원리

        //한 과정에서 두 수의 위치를 서로 바꿔주는 작업 밖에 하지 못하고 
        //자료의 개수가 많아질수록 성능이 떨어지는 알고리즘

        /*내풀이
        function solution(arr){
            let answer;
            for(let i = 0; i < arr.length - 1; i++){
                for(let j = 0; j < (arr.length - 1) - i; j++){
                    if(arr[j] > arr[j + 1]){
                        let temp = arr[j + 1] //위치를 바꿔주기 위해 임시로 값을 잡아둘 변수
                        arr[j + 1] = arr[j];
                        arr[j] = temp;
                    }
                }
            }
            answer = arr;
            return answer;
        }
        
        
        let a = [9, 10, 5, 13, 1, 6, 17, 4];
        /*
        // < legnth - 1 = 6
        9 / 17 -> 0, 6
        10 / 6 -> 1, 5
        5 / 1 -> 2, 4
        13 / 13 -> 3, 3
        1 / 5 -> 4, 2
        6 / 10 -> 5, 1
        17 / 9 -> 6, 0
        
        console.log(solution(a));
        */

        /*내림차순으로 바꿔서 풀어보기
        function solution(arr){
            let answer;
            for(let i = 0; i < arr.length - 1; i++){
                for(let j = 0; j < (arr.length - 1) - i; j++){
                    if(arr[j] < arr[j + 1]){
                        let temp = arr[j + 1];
                        arr[j + 1] = arr[j];
                        arr[j] = temp;
                    }
                }
            }
            answer = arr;
            return answer;
        }
        
        
        let a = [9, 10, 5, 13, 1, 6, 17, 4];
        console.log(solution(a));
        */

        //해설코드
        function solution(arr){
            let answer = arr;
            for(let i = 0; i < arr.length -1; i++){ //한 번의 반복마다 배열의 가장 뒷자리에 가장 큰 수가 하나씩 들어차므로, 
                //결국에 총 반복 횟수는 arr.length - 1 번이 필요함(단지. 0번도 반복횟수에 포함 되므로 < arr.length - 1이 되는 것)
                for(let j = 0; j < (arr.length -1) - i; j++){
                    if(arr[j] > arr[j+1]){
                        [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
                    }
                }
            }
            return answer;
        }
        let arr = [13, 5, 11 ,7, 23, 15];
        console.log(solution(arr));
    </script>
</body>
</html>