<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //section8. 재귀함수와 완전탐색
      //62. 재귀함수
      /*해설코드
      function solution(n){
                function DFS(L){
                    if(L==0) return;
                    else{
                        DFS(L-1);
                        console.log(L);   
                    }
                }
                DFS(n);
            }

            solution(3);
        */

      /*재풀이 1
      function solution(n) {
        function DFS(L) { //재귀함수 생성, 재귀(recursion): 함수가 자기 자신을 호출, 재귀함수: 함수가 자기 자신을 호출하는 구조로 만들어진 함수
          if (L == 0) return; //재귀함수의 종료 조건, L === 0 이 되면 종료.
          //재귀함수의 종료조건을 설정해주지 않으면 무한 반복

          //스택 오버플로우(stack overflow): 재귀 호출로 인해 스택에 프레임이 무한하게 쌓이면서, 
          //스택의 공간을 다 차지하고 더 이상 여유 공간이 없을 때,
          //스택 영역을 넘어서서 저장되는 데이터가 쌓이는 순간 오동작 및 보안상의 취약점이 생김.
          //때문에 에러를 발생시키고 강제 종료

          else {
            console.log(L); //L을 찍고  
            DFS(L - 1); //DFS(L-1), 즉 자기 자신을 다시 호출(재귀)
          }
        }
        DFS(n);
      }

      solution(3); // 3, 2, 1
      // 문제의 조건처럼 1, 2, 3순서로 반환하려면?
      */

      /*재풀이 2
      function solution(n) {
        function DFS(L) {
          if (L == 0) {
            return;
          } else {
            DFS(L - 1); // 위의 풀이와 다르게 console.log(L);이 실행되기 전 즉, L을 찍기 전에 자기 자신을 호출하는 DFS(L-1)을 만나 재귀
            //최종적으로 solution(3)이 반환하는 값은 1, 2, 3이 나옴
            //왜?

            //메모리의 스택(stack) 영역에는 함수의 호출과 관계되는 지역변수와 매개변수가 저장 됨
            //스택 영역은 함수의 호출과 동시에 할당이 되고, 함수의 호출이 완료되면 소멸
            
            //함수가 호출 되면 스택에는 함수의 매개변수, 함수에서 선언된 지역변수, 함수의 호출이 완료된 이후 돌아갈 반환 주소값 등이 저장 됨
            //이렇게 스택 영역에 차례대로 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라 함.
            
            //예를 들어, 함수를 호출하여 실행하다 함수 내부에서 또다른 함수를 호출하는 경우가 발생했을 때
            //새로운 스택 프레임이 스택영역의 최상단에 생성되며
            //해당 함수의 실행이 종료 되었을 때 해당 스택프레임은 스택 영역에서 제거 되고, 
            //이어서 함수를 실행하는 과정에서 현재 스택영역의 최상단에 위치한 
            //스택프레임에 저장 되어 있는 변수들에 관한 정보나, 호출이 끝난 뒤 돌아갈 반환 주소값 덕분에
            //해당 함수가 호출되기 이전의 상태로 자연스럽게 돌아갈 수 있는 것임

            //console.log(L);을 만나기 전에 자기 자신을 호출하는 DFS(L-1)을 만났으므로
            //재귀를 반복하다 L값이 0이 되었을 때 반복이 종료 되며
            //스택 영역에 저장된 최상단의 스택프레임 부터 함수의 호출이 완료되면서 소멸하는 과정에서
            //L값이 1인 경우 DFS(0)을 실행하고 재귀가 종료된 이후 ,
            //스택프레임에 저장 된 돌아갈 반환 주소값으로 돌아와 console.log(L)을 마저 실행하게 되고(1반환) 
            //현재 최상단의 스택프레임은 호출이 완료되면서 자연스럽게 소멸

            //이후 현재 스택영역의 최상단에 쌓인 스택프레임은 L값이 2인 경우이므로 
            //마찬가지로 스택프레임에 저장 된 반환 주소값으로 돌아와 console.log(L)을 마저 실행하게 되고(2반환)
            //현재 최상단의 DFS(2) 스택프레임은 스택영역에서 제거 됨

            //이 때문에 DFS(L-1) 즉, 자기 자신을 호출하는 함수의 위치에 따라 
            //최종적으로 solution함수가 반환하는 값이 달라지는 것임(3, 2, 1 과 1, 2, 3)
            console.log(L);
          }
        }

        DFS(n);
      }

      solution(3); //1, 2, 3
      */

      //최종풀이
      function solution(n) {
        function DFS(L) {
          //2. 재귀함수 생성
          if (L == 0) {
            return; //3. 재귀함수 종료 조건
          } else {
            //4. 주어진 조건에 만족하는 출력 시작
            DFS(L - 1); //제일 처음, DFS(3)이 실행되다 DFS(2)가 호출, 이때 DFS(3)에 대한 스택 프레임이 생성 되고 DFS(2)가 실행(재귀)
            //마찬가지로 DFS(2)가 실행되다 DFS(1)이 호출, 이때 DFS(2)에 대한 스택 프레임이 생성 되고 스택 영역의 최상단에 위치,
            //DFS(1)이 실행되고 DFS(0)이 호출, DFS(1)에 대한 스택 프레임이 생성 되고 스택 영역의 최상단에 위치,
            //DFS(0)이 실행되면서 DFS(0)에 대한 스택 프레임이 생성되지만, 재귀가 종료되며 스택 프레임도 소멸

            console.log(L); ////이후, 현재 스택 영역의 최상단에 위치한 DFS(1)에 대한 스택 프레임에 저장된 주소값 즉,
            //DFS(1)이 실행되다 재귀함수가 호출된 지점으로 돌아와 console.log(1)을 마저 실행하여 1반환
            //위와 같은 과정이 DFS(3)까지 반복되어 1, 2, 3을 차례로 반환한 이후 모든 스택프레임이 소멸하고
            //함수의 동작이 끝나게 됨
          }
        }

        DFS(n); //1. 재귀함수 호출
      }
      solution(3);
    </script>
  </body>
</html>
