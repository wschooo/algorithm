<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //4.완전탐색
        //뒤집은 소수
        //풀이 전 찾아서 정리한 것들
        // 소수(Prime Number): 1과 자기 이외의 자연수로 나눌 수 없는 1보다 큰 자연수. 즉, 양의 약수를 2개만 가지는 숫자.
        
        // ex) 숫자 N이 소수인지 아닌지 어떻게 판별해야 할까?
        
        // 1) 숫자 N이 2부터 N보다 작은 N-1까지 나눠 떨어지는지 반복해본다
        //    -> N을 2부터 N-1까지 나눴을 때 나눠 떨어지면(나머지가 0) 1과 자기 자신 이외의 약수를 가지게 되므로 소수가 아님
        //    -> N-1까지 나눴을 때 나눠 떨어지는 경우가 없으면 소수
        //    -> 단순하지만 확실한 반면에 숫자 N이 큰 숫자라면 수많은 연산을 거쳐야 됨
        
        // 2) 에라토스테네스의 체(sieve) 응용
        //    -> 에라토스테네스의 체?
        //    -> 소수를 찾기위한 일종의 소거법
        //    -> if) 1부터 100사이의 소수를 찾는다면... 1은 소수가 아니므로 제외시키고 2부터 소수를 찾아 나간다
        //    -> how?
        //    -> 2는 소수이므로 소거하지 않고 100까지의 2의 배수를 전부 소거한다 
        //       *배수란 것은 수의 곱절들의 모임, 즉 1과 자기자신 곱 이외의 숫자들의 곱으로 나타낼 수 있으므로 소수가 아님을 의미
        //    -> 3은 소수이므로 소거하지 않고 100까지의 3의 배수를 전부 소거한다
        //    -> 4는 2의 배수이며 4의 배수는 모두 2의 배수이므로 자동으로 소거가 되어있다
        //    -> 5는 소수이므로 소거하지 않고 100까지의 5의 배수를 전부 소거한다
        //    -> 6은 2와 3의 배수이므로 6의 배수는 모두 2와 3의 배수이므로 자동으로 소거가 되어있다
        //    -> 7은 소수이므로 소거하지 않고 100까지의 7의 배수를 전부 소거한다
        //    -> 8은 2와 4의 배수이므로 8의 배수는 모두 2와 4의 배수이므로 자동으로 소거가 되어있다
        //    -> 9는 3의 배수이므로 9의 배수는 모두 3의 배수이므로 자동으로 소거가 되어있다
        //    -> 10은 2와 5의 배수이므로 10의 배수는 모두 2와 5의 배수이므로 자동으로 소거가 되어있다
        //    -> 11은 소수이므로 소거하지 않고 11의 배수를 모두 소거한다
        //     * 11의 배수를 소거하려고 보니 이미 100까지의 11의 배수는 전부 소거가 되어있다(22, 33, 44, 55, 66, 77, 88, 99)
        //      ........
        //    -> 13은 소수이므로 소거하지 않고 13의 배수를 모두 소거한다
        //     * 13의 배수를 소거하려고 보니 이미 100까지의 13의 배수는 전부 소거가 되어있다(26, 39, 52, 65, 78, 91)
        
        // 2-1) 왜 그럴까?
        //     -> 이미 앞에서 소수들의 배수를 소거할 때 소거가 되었기 때문이다
        //     -> 예를 들어, 11 * 2, 11 * 3, 11 * 4, 11 * 5, ..... , 11 * 9 를 뒤집으면
        //        2 * 11, 3 * 11, 4 * 11, 5 * 11, ..... , 9 * 11 이고 이는 11보다 작은 숫자들의 배수를 소거하는 과정에서 이미 소거가 되었음을 의미한다
        //     -> 여기서 알 수 있는 것은 2, 3, 4, 5, 6 ... 과 같이 숫자를 하나씩 높이면서 소거해 나갈때
        //     -> 예를 들어, 6다음은 7이니까
        //     -> 소거가 되어있지 않은 수(7)는 이전의 수(2, 3, 4, 5, 6)들의 배수가 아님을 의미하고
        //     -> 배수가 아니란 것은 현재 그 숫자는(7) 소수임을 의미한다.
        //     -> 또한 소수의 배수를 소거해 나갈 때 자신과 자신의 곱 부터 제거를 해나가면 된다는 것을 알 수 있다.
        //     -> 예를 들어, 7의 경우 7 * 7 부터 7 * 8, 7 * 9 ... 7 * 14를 소거하면 된다는 것이다
        //     -> 이유는 다시 한 번 적지만 7 * 6 까지는( 2 * 7, 3 * 7, 4 * 7, 5 * 7, 6 * 7) 이미 이전 과정에서 소거가 돼있기 때문이다
        
        // 2-2) 의문점 
        //     -> 그럼 위와 같은 방법에 따라 7의 배수를 소거하고 8, 9, 10은 각각 숫자들의 배수이므로 건너 뛰고 소수 11의 배수들을 소거할 차례이다
        //     -> 11 * 11 이전의 곱(11 * 2, 11 * 3, ... , 11 * 10)들은 앞의 숫자들의 배수를 소거하면서 다 소거가 되었기 때문에
        //     -> 11 * 11(121) 부터 소거를 하려고 보니 이미 주어진 조건(1부터 100까지)의 범위를 넘어버렸다
        //     -> 정확히는 11 * 9 까지가 조건을 만족하는 마지막 곱이다
        //     -> 소수가 아니기에 이미 소거가 되어있는 10 * 10 부터 다시 소거를 해본다 해도 
        //     -> 그 다음 차례인 10 * 11 역시 범위를 넘어버리므로 더이상 소거할 필요가 없다 
        //     -> 결국 10 * 10까지만 소거를 하고 그 이후로는 소거할 필요가 없다는 것인데
        //     -> 너무나 당연하게도 10 * 10이 100이므로 주어진 범위의 마지막 숫자이므로 그렇다
        //     -> 하지만 주어진 범위가 예를 들어 140 까지라면?
        //     -> 소거가 진행 될 마지막 곱이 11 * 11 ... 11 * 12 까지인데
        //     -> 이건 10 * 10 처럼 주어진 범위와 완벽하게 맞아 떨어지지 않는다
        //     -> 이에 대한 명확한 기준을 알아야 코드를 짤 수 있다
        
        // 2-3) 제곱근을 생각해보자
        //     -> 주어진 범위가 1부터 140까지라면 어떻게 탐색을 진행하면서 소수를 찾아 반환할 것인가?
        //     -> 소수가 아닌 숫자(소수들의 배수)를 소거해나가면서 결국 소수만 남기는 방법은 알게 되었다.
        //     -> 이를 어떻게 표현 할 수 있을 것인가? 마지막으로 소거를 끝낼 지점을 무엇을 기준으로 설정해야 하는가?
        //     -> 때문에 제곱근을 먼저 생각을 해야한다. 
        //     -> 예를 들어, 64라는 숫자의 인수로는 1, 2, 4, 8, 16, 32, 64 가 존재한다
        //     -> 8은 64의 제곱근이며 숫자 N의 제곱근이 자연수라면 숫자 N의 인수는 홀수개가 생김을 알 수 있다
        //     -> 그리고 64라는 숫자는 1 * 64, 2 * 32, 4 * 16, 8 * 8, 64 * 1, 32 * 2, 16 * 4로 나타낼 수 있음을 알 수 있다
        //     -> 제곱근의 역할이 무엇인지 보인다. 인수들의 곱은 서로 쌍을 이루기 때문에
        //     -> 자연수 N을 구성하는 인수 a, b(a, b가 제곱근 N이 아니라면)의 곱으로 나타낼 때 min(a,b) < 제곱근 N이 되고
        //     -> 결국 제곱근 N의 역할은 숫자 N을 인수들의 곱으로 나타낸 값에 대한 중간값(대칭점)이 되는 것이다
        //     -> 이게 무슨 의미가 있는가?

        // 2-4) 탐색의 기준점인 제곱근
        //     -> 숫자 N을 인수들의 곱으로 나타낼 때 제곱근 N은 인수들의 곱의 정확히 중간값이기 때문에
        //     -> 제곱근 N이 아닌 숫자 N의 인수 a,b 중 더 작은 값은 제곱근 N보다 항상 작을 수 밖에 없고
        //     -> 제곱근 N이라는 중간지점(대칭점)을 넘어서면 a * b = N이 b * a = N으로 나타나므로
        //     -> 제곱근 N보다 작은 인수까지만 탐색을 진행해도 된다는 것을 알 수 있다.
        //     -> 다시 처음으로 돌아와 에라토스테네스의 체를 응용해 1부터 100까지의 숫자 중 소수를 찾는다고 할 때
        //     -> 해당 숫자가 소수인지 판단하기 위해서는 100의 제곱근인 10까지(중간값)까지만 소거를 진행하면
        //     -> 11 * 11 부터는 소거 할 필요가 없어지는 것이다(a와 b가 10보다 크므로)
        //     -> 만약 주어진 범위가 1부터 140까지라면 어떨까?
        //     -> 140의 제곱근은 11.8321595662이고 자연수가 아니므로 인수가 되지 못한다
        //     -> 다만 11.8321595662은 인수의 중간값이자 대칭점이 되므로
        //     -> 11.8321595662 보다 작은 자연수인 11까지만 에라토스테네스의 체를 통한 소거법을 진행하면
        //     -> 더이상 소수를 소거하기 위한 탐색을 진행하지 않아도 됨을 알 수 있다
        //     -> 즉 소수 11의 배수인 11 * 11 부터 시작하여 11 * 12까지만 소거를 진행하면 끝나는 것이다
        
        
        // 2-5) 그럼 에라토스테네스의 체를 활용한 코드는 어떻게 짜야할까?
        //     -> 주어진 범위가 N까지라고 가정을 하면
        //     -> N까지의 범위 내에서
        //     -> N의 제곱근보다 작거나 같은 자연수들의 배수를 지워나가면 된다

        // 2-6) 혹은 이런 방법은?
        //     -> 1부터 140까지의 숫자 중 소수를 출력한다고 할 때
        //     -> 1부터 140까지 탐색을 돌면서 숫자 N이 소수인지 아닌지 판단하기 위해 
        //     -> 숫자 N의 제곱근 보다 작은 수까지 탐색을 하고
        //     -> 만약 숫자 N의 제곱근 보다 작은 수 중에 인수가 없다면(나눠떨어지지 않는다면) 
        //     -> 해당 숫자는 소수가 되는 것이다
        

        
        /*내풀이
        function solution(a){
            let answer = [];
                for (let i of a){
                    for (let j = 2; j < Math.sqrt(i); j++)
                    if(i % j !== 0){    //이 반복의 문제점은 2부터 i의 제곱근까지 i / j의 나머지가 0이 아니기만하면
                       answer.push(i);  //빈배열 answer에 i를 push를 해버려서 입력조건을 만족시킬 수가 없음
                }
            }
        return answer; 
        }
            let arr=[32, 55, 23, 20, 250, 370, 200, 30, 100];
            console.log(solution(arr));
        */
            

        /*재풀이
        function solution(a){
            let answer = [];
                for (let i of a){
                    for (let j = 2; j < Math.sqrt(i); j++)
                    if(i % j === 0){
                       return; //2부터 i의 제곱근 까지 i / j 의 나머지가 0이면(나눠 떨어지면) 인수를 갖는다는 것이므로 바로 return해서 반복을 종료
                    }
                else {
                    answer.push(i); //그렇지 않으면 빈배열 answer에 i를 push
                }
            }
        return answer; 
    }
            let arr=[32, 55, 137, 20, 250, 370, 200, 30, 100];
            console.log(solution(arr));
            //문제점: 값이 undefined가 나옴. 즉 배열에 아무것도 push가 되지 않고,
            // i % j !== 0 인 모든 경우에 대해서 빈배열에 i가 중복해서 push될 것 같음
            // 물론 값은 여전히 undefined만 출력 됨
            */
            
            /*재재풀이
            function solution(a){
            let answer = [];
                for (let i of a){
                    let check = true; //미리 i % j의 나머지가 0인지(인수를 갖는지) 판단하기 위해 check변수를 만들고 그 값으로 true를 할당 
                    for (let j = 2; j < Math.sqrt(i); j++)
                    if(i % j == 0){  //만약 2부터 i의 제곱근까지 i / j 의 나머지가 0인 경우가 단 하나라도 있다면 인수를 갖는다는 것이므로 
                       check = false; //check 변수를 false로 바꿔주고
                }
                if(check === true){ //인수가 없는 경우(여전히 check가 true)라면 소수가 되므로
                    answer.push(i); //빈배열 answer에 i를 push
                }
            }
        return answer; 
    }
            let arr=[32, 55, 137, 20, 250, 370, 200, 30, 100];
            console.log(solution(arr));
            // i % j !== 0은 언뜻 생각하면 i를 j로 나눴을 때 나머지가 0이 아니라는 것은 인수가 아니라는 말이므로
            // 탐색을 하면서 i % j !== 0을 만족 즉, 인수가 없다면 소수다! 생각할 수 있지만
            // 말 그대로 반복문을 통한 탐색은 2부터 제곱근 i까지 j를 1씩 증가시키며 i % j를 실행하므로
            // 주어진 모든 반복이 끝난 이후 1 % j !== 0이라는 조건을 판단하는 것이 아니다
            // 즉, 2부터 i의 제곱근까지 i % j !== 0 인지 아닌지 판단한 이후 j를 1씩 증가시키는 반복을 하므로 
            // 모든 j가 i % j !== 0 인 경우를 만족하는 것이 아닌
            // i % j !== 0을 만족하는 경우가 단 하나라도 있다면 주어진 조건을 통과하기 때문에 조건 자체가 잘못된 것이다 
            // 숫자 N은 2부터 제곱근 N까지의 모든 숫자를 자신의 인수로 가질 수 없기 때문
            // -> 2부터 제곱근 N까지 숫자 N의 인수인 숫자도 있고 아닌 숫자도 있는데
            // -> 인수가 아닌 숫자가 단 한개라도 있기만 하면 소수라고 판정을 하게 되므로 조건이 잘못되는 것임
            // 그렇기에 역으로 생각하여 2부터 제곱근 N까지 i를 j로 나눴을 때 나눠 떨어지는 수가 있으면(인수가 있으면)
            // 주어진 조건을 만족시키지 못하는 방향으로 바꿔줘야 함
            */
            
            
            /*최종풀이(배열의 요소를 뒤집는 입력조건 추가)
            function solution(a){
            let answer = [];
            //배열의 요소 뒤집기
            //배열을 문자열로 바꾸고 split으로 하나하나 배열화를 해준 이후, reverse로 앞뒤를 바꾸고 다시 문자열로 join
            //let b = a.toString().split('').reverse().join(''); 
            //확인용
            //console.log(b); // 001, 03, 073, 052 ... , 55, 23 까지는 출력 되지만
            //여기서 001과 073과 같은 것들을 1과 73과 같은 올바른 숫자로 바꿔야한다
            //parseInt와 Number의 사용은 오류가 발생하고
            for (let i of b){
                let check = true; 
                    for (let j = 2; j < Math.sqrt(i); j++)
                    if(i % j == 0){ 
                       check = false;
                }
                if(check === true){
                    answer.push(i);
                }
            }
        return answer; 
        //parseInt(answer); // answer 자체를 정수화를 시켜도 당연히 될 리가 없다
    }
            let arr=[32, 55, 137, 20, 250, 370, 200, 30, 100];
            console.log(solution(arr));
            */

            
            //해설코드
            /*2 소수인지 아닌지 판단해주는 함수 만들기
            function isPrime(num){
                if(num === 1){
                    return false;
                }
                for(let j = 2; j <= parseInt(Math.sqrt(num)); j++){
                    if(num % j === 0){
                        return false;
                    }
                }
                return true;
            }


            /*1 배열의 요소(숫자)를 뒤집고(split과 reverse를 쓰지 않고 숫자자체로 주어진 배열의 요소를 뒤집는 방법)
            function solution(arr){
                let answer = [];
                for(let i of arr){
                    let res = 0;
                    while(i){
                        let t = i % 10; //배열의 요소(숫자)의 가장 마지막자리를 의미하는 변수 t
                        res = res * 10 + t; //값이 0인 res변수에 *10을하여 자릿수를 하나 당겨주면서 배열의 요소(숫자)의 가장 마지막 자리를 더해주고
                        i = Math.floor(i / 10); // 배열의 요소(숫자)i를 10으로 나눠준 몫을 i에 다시 저장
                    }
                    if(isPrime(res)){   //숫자를 뒤집은 것(res)이 소수이면
                        answer.push(res);   // answer에 res를 push
                    }                       // isPrime이란 내장함수가 있는 것이 아니므로 소수를 판단하는 함수를 하나 만들어야 한다
                }

                return answer;
            }
            */

            /*1-1 배열의 요소(숫자)를 뒤집고(split과 reverse를 사용하는 방법)
            function solution(arr){
                let answer = [];
                for(let i of arr){
                    let res = parseInt(i.toString().split('').reverse().join(''));
                    //주어진 배열 전체(arr)를 뒤집는 것이 아닌, 배열의 요소(i)를 하나하나 뒤집어준 것
                    //내풀이에서는 주어진 배열 전체를 뒤집은 이후 이를 숫자화 시켜주는 과정에서 오류가 발생
                    //배열의 각 요소가 아닌 전체를 뒤집고 문자열을 숫자화를 시키면 확인용2에서 볼 수 있는 것 처럼
                    //문자의 가장 처음에 오는 부분만 숫자화가 되고 ','이후의 문자는 전부 무시된다
                    //따라서 배열 전체가 아닌 배열의 요소 하나하나를 뒤집어줘야 함
                    //console.log(res);
                    if(isPrime(res)){   //숫자를 뒤집은 것(res)이 소수이면
                        answer.push(res);   // answer에 res를 push
                    }                       // isPrime이란 내장함수가 있는 것이 아니므로 소수를 판단하는 함수를 하나 만들어야 한다
                }

                return answer;
            }
            
            let arr=[32, 55, 36, 77, 505, 62, 20, 250, 370, 200, 30, 100];
            console.log(solution(arr));
            //확인용2
            //console.log(parseInt('3,32111,4555,666,774,311'));
            //console.log(parseInt('32'));
            */


            /*최종풀이 보완1(split,reverse,join사용 X)
            function solution(a){
            let answer = [];
            for(let i of a){
                let res = 0;
                while(i){
                    let reNum = i % 10;
                    res = res * 10 + reNum;
                    i = Math.floor(i / 10);
                }
                let check = true;
                for(let j = 2; j < Math.sqrt(res); j++){
                    if(res % j === 0){
                        check = false;
                    }
                }
                if(check === true){
                    answer.push(res);
                }
            }
            return answer; 
        }
            let arr=[32, 55, 1307, 20, 250, 34450, 200, 30, 129];
            console.log(solution(arr));
            */

            //최종풀이 보완2(split,reverse,join사용 + 오류수정)
            function solution(a){
            let answer = [];
            for(let i of a){
                let rev = parseInt(i.toString().split('').reverse().join(''));
                //console.log(rev);
                let check = true;
                for(let j = 2; j < Math.sqrt(rev); j++){
                    if(rev % j === 0){
                        check = false;
                    }
                }
                if(check === true){
                    answer.push(rev);
                }
            }
            return answer; 
        }
            let arr=[32, 55, 1307, 20, 250, 34450, 200, 30, 129];
            console.log(solution(arr));
            
    </script>
</body>
</html>