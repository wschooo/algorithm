<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //7. 정렬,그리디,결정알고리즘
      //52. 삽입 정렬

      //삽입 정렬
      //여러 개의 숫자가 섞여 있을 때 작은 숫자부터 큰 숫자로 정렬하는 것
      //첫 숫자는 그대로 놔두고 두 번째 자리의 숫자부터 뽑아 그 숫자가 첫 번째 자리의 숫자보다 크면 첫 숫자 오른쪽에, 작으면 왼쪽에 넣음
      //이후 세 번쨰 자리의 숫자를 뽑아서 앞의 두 숫자와 크기를 비교해 알맞은 자리에 넣는다
      //예를 들어 가장 왼쪽에 넣거나, 두 숫자 사이에 넣거나, 가장 오른쪽에 넣는 것
      //이렇게 끝까지 반복하면 크기가 오름차순으로 정렬이 됨

      //ex) [5, 6, 1, 2, 4, 3]
      //첫 번째는 넘어가고 두 번째부터 시작.
      //숫자 6을 선택하고 앞의 5와 비교하는데 5보다 크기 때문에 그냥 그 자리에 둔다(오른쪽). 그리고 다음 숫자 1을 선택.
      // -> [5, 6, 1, 2, 4, 3]
      //1은 앞의 5, 6보다 작기 때문에 5, 6 앞에 넣어준다.
      // -> [1, 5, 6, 2, 4, 3]
      //다음 숫자 2를 선택하고 2는 1보다는 크고, 5와 6보다는 작기 때문에 그 사이에 넣어준다.
      //[1, 2, 5, 6, 4, 3]
      //다음 숫자인 4를 선택
      //마찬가지 과정으로 1,2보다 크고 5,6 보다 작으므로 1,2 그리고 5,6 사이에 넣어준다.
      // -> [1, 2, 4, 5, 6, 3]
      //다음 숫자인 3을 선택
      //1,2보다 크고 4,5,6 보다 작으므로 1,2 그리고 4,5,6 사이에 넣어준다.
      // -> [1, 2, 3, 4, 5, 6]
      //이후 선택할 다음 숫자가 더는 없으므로 반복을 종료함.
      // -> [1, 2, 3, 4, 5, 6] 정렬 완료

      //안정적인 정렬 알고리즘이지만 배열 안 요소들의 이동 수가 많고 배열의 크기가 큰 경우 시간이 오래걸린다는 단점
      //배열의 길이가 짧고 배열 안 요소들이 대부분 정렬 되어있는 상태라면 이동의 횟수가 많이 줄어들기 때문에, 효율성이 올라감

      /*내풀이
    function solution(arr){
        let answer;
        for(let i = 1; i < arr.length; i++){ //배열의 두 번째 요소부터, 배열의 끝 요소까지 탐색
            let j = i; // i를 변수 j에 저장하는 이유는 현재 탐색이 진행되는 위치를 그대로 유지하기 위함임
            //예를 들어, i를 j에 저장하지 않고 그대로 i값을 기준으로 탐색을 진행한다면 정답은 도출되지만
            //밑에 while문에서 i의 값에 변화가 생기면(i-- 때문)
            //i는 for반복문에서 1로 재할당되어 앞에서부터 불필요한 반복이 또 시작 됨
            //즉, while문으로 인해 배열 안에서 요소의 위치가 재조정 될 때 마다
            //앞에서 부터 다시 탐색을 시작하고, while문으로 인한 배열안 요소의 위치의 재조정이 없을 때 = 오름차순이 완성 되어 while문이 더이상 작동하지 않을 때(정답일 때)
            //불필요한 반복이 비로소 종료 되는 것임
            //때문에 i가 인덱스 위치에 따라 영향받지 않게 하기 위해 i의 현재 탐색 위치(인덱스)만 대신 받아줄 변수가 필요한 것임
            //(마찬가지로 while문으로 j값이 변화가 생겼다 해도(j--때문) 어차피 다음 탐색이 진행 될 때 let j = i;(변수에 현재 인덱스 저장) 인해 현재 위치로 초기화 되므로 상관 없음)
            
            while(arr[j - 1] > arr[j]){ //바로 앞에 위치한 요소가 현재 위치의 요소보다 클 경우 true(반복)
                // -> 바로 앞에 위치한 요소가 현재 위치의 요소보다 작을 경우 false가 되어 반복 중지
                // -> 즉 더 작은 숫자를 왼쪽으로 밀어 나가는 것임
                let temp = arr[j - 1]; //두 요소를 바꿔주기 위해 둘 중 하나를 임시 변수에 저장해두고
                arr[j-1] = arr[j]; // 서로 위치를 바꿔줌
                arr[j] = temp; //서로 위치를 바꿔줌
                j--; //배열의 끝 요소까지 탐색해야 하므로 인덱스 번호를 하나씩 줄여가면서 계속 판단
                //-> 예를 들어 while문이 true상태일 때, 즉 앞에 위치한 요소가 현재 위치의 요소보다 크다면
                //while문 내부 코드가 실행되어 서로 위치가 바뀌고
                //위치가 바뀌는 만큼 인덱스 번호가 바뀐 것을 계속 반영해줘야 함
            }
        }
        answer = arr;
        return answer;
    }
    let a = [11, 7, 5, 6, 10, 9];
    console.log(solution(a));
    */

      /*해설코드
    function solution(arr){
                let answer=arr;
                for(let i=1; i<arr.length; i++){ //배열의 두 번쨰 요소부터 탐색 시작
                    let tmp=arr[i], j; //tmp변수에 arr[i]값, 즉 탐색을 처음 시작했을 때 요소 값을 저장
                    //j를 선언한 것은 스코프 범위를 벗어나는 것을 방지하기 위함
                    for(j=i-1; j>=0; j--){ //j는 i-1부터, 즉 i의 앞의 요소부터 탐색을 시작하여 j > = 0이 될 때까지(배열의 가장 첫번째 위치까지)탐색
                        //오른쪽에서 왼쪽 방향으로 하나씩 탐색하여 나가는 것
                        if(arr[j]>tmp) arr[j+1]=arr[j]; // 왼쪽에 위치한 요소가 탐색을 처음 시작한 요소 보다 크다면, 그 값을 바꿔주고
                        else break; // 그렇지 않으면, 즉 위치를 바꾸어 오름차순 정렬할 필요가 없으면, 반복작업 중지
                    }
                    arr[j+1]=tmp; //반복이 종료 or 멈춘 지점(요소간 비교했을 때 정렬할 필요가 없을 때)의 다음 자리에 탐색을 처음 시작했을 때의 요소를 넣어주기
                } //비교 대상이 arr[j]이고, arr[j]가 tmp보다 작으므로 arr[j]의 다음 자리에 tmp변수를 넣어주는 것임
                return answer;
            }

            let arr=[11, 13, 5, 6, 10, 9];
            console.log(solution(arr));
            */

      //재풀이
      function solution(arr) {
        let answer = arr;
        for (let i = 1; i < arr.length; i++) {
          //i는 배열의 두번쨰 요소부터 시작
          let tmp = arr[i],
            j; //시작 지점의 요소를 임시 변수로
          for (j = i - 1; j >= 0; j--) {
            // j는 i요소의 바로 앞 부터 배열의 가장 첫번쨰 요소까지 탐색
            if (arr[j] > tmp) {
              // 현재 시작점의 요소보다 그 앞에 있는 요소가 크다면 -> 즉 오름차순에서의 알맞은 자리를 찾아주기 위해
              arr[j + 1] = arr[j]; //기준이 되는 요소 arr[i](tmp)보다 큰 숫자들이 앞의 요소(arr[j]) 중에 존재한다면 한칸씩 뒤로 밀어내는 것
            } else {
              // 기준이 되는 요소 arr[j]보다 작은 숫자가 앞의 요소 중에 발견 됐을 때
              break; // 탐색 중지
            }
          }
          arr[j + 1] = tmp;
        }
        return answer;
      }
      let arr = [14, 13, 5, 6, 10, 9];
      console.log(solution(arr));
    </script>
  </body>
</html>
